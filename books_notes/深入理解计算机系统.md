《信息的表示与处理》
============

----------

**浮点数**溢出会产生特殊的值正无穷大。但一组正数的乘积总是正的，由于表示的精度有限，浮点运算是**不可结合的**。
eg：3.14+（1e20-1e20）=3.14; (3.14+1e20)-1e20=0.0

整数运算是精确的，而浮点数是近似的。

----------

**C语言版本演变：** K＆R第一版 (Bell Lab)——> ANSI C(美国国家标准) ——> ISO C90 (C89) ——> ISO C99  (gcc -std=c99 proc.c)

----------

**虚拟存储器：**将计算机的存储器视为一个非常大的数组，存储器的每个字节由一个数字来表示，称为地址。虚拟n存储器可以包括RAM，磁盘，特殊硬件等的虚拟访问。

----------

**十六进制的转换运算:**

对于x=2^n, x的二进制表示为1后面跟n个0，如：8=2^3=00001000 ，十六进制的数字0代表4个二进制0 。

所以当n表示为i+4j时，其中0<=i<=3时，可以将x写成开通的十六进制数字为1（i=0），2（i=1），4（i=2），8（i=3），后面跟随j个十六进制的0.

如 x=2048=2^11,所以有n=11=3+4＊2.从而得到x=0x800

----------

**C中数据类型的字节数**
_______________________________________________________
C类型		|	32bit机器	|		64bit机器          
_______________________________________________________
													    	
char 		|		1		|			1
_______________________________________________________
short int	|		2		|			2
_______________________________________________________
int			|		4		|			4
_______________________________________________________
long int	|		4		|			8
_______________________________________________________
long long int |		8		|			8
_______________________________________________________
char *		 | 		4		|			8
_______________________________________________________
float		|		4		|			4
_______________________________________________________
double		|		8		|			8
________________________________________________________

----------

**寻址**
多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中**最小地址**

**little endian:** 最低有效数字在最前面的方式,大多数Intel兼容机都采取这种规则
**big endian:**	 最高有效数字在最前面的方式，大多数IBM和Sun MicroSystem采取这种规则

eg： 假设x为int，位于地址0x100，值为0x01234567，占四个字节

little endian： 0x100(01) 0x101(23) 0x102(45) 0x103(67)

big endian： 0x100(67) 0x101(45) 0x102(23) 0x103(01) 

----------

**布尔代数：**

异或：^,当p=0 且 q=1 或者 p=1 且q=0,p^q=1

----------

**移位运算：**

左移：x=01100011  x<<4=00110000

逻辑右移动：x=01100011 x>>4==00000110

算术右移: x=01100011 x>>4=11111001 (左端补k个最高有效位的值)

大多数编译器／机器组合都对有符号书进行算术右移

C语言中，加法（减法）优先级高于移位运算。即1<<2+3<<4 = 1<<(2+3)<<4 。


x<<k = z^k * x

x>>k = x / 2^k (无符号数使用逻辑右移，有符号数字使用数学右移)

----------

**整数表示**

有符号整数表示采用补码表示，即最高位为1时，表示值为负，最高为为0时，表示值为非负（包括0） 

补码的范围不固定:|TMin|=|TMax|+1 

补码能表示的正数比负数少一个，因为0是非负数。

最大的无符号数值刚好比补码的最大值大1，即UMax=2TMax+1 

C中的强制类型转换的结果是保持位值不变，只是改变了**解释**这些位的方式

```c
unsigned u=4294967295u ;/*UMax_32*/

int tu= (int)u ;

tu == -1 ;

```

C中的比较
运算，当一个运算数是无符号时，另一个运算数会被隐式转换为无符号，如-1<0u, 即转换为4294967295U<0U，结果是false

----------


**浮点数表示**

二进制小数：101.11_2= 1*2^2 + 0*2^1 + 1*2^0 + 1*2^-1 + 1*2^-2=4+0+1+1/2+1/4=5 + 3/4

二进制小数点向左移动一位相当于将该数乘以2，如：1011.1=8+0+2+1+1/2=11+1/2 

浮点数只能近似表示实数，采用**舍入**的方式来求近似值，舍入有四种情况：**向偶数舍入，向零舍入，向下舍入，向上舍入**



《程序的机器级表示》
============

基本编译命令：
``` sh
 #生成汇编代码:"-S"表示生成汇编代码，"-O1"表示做level 1的优化
 $>gcc -O1 -S code.c

 #生成Intel格式的汇编代码：
 $>gcc -O1 -S -masm=intel code.c 

 #编译并汇编代码：
 $>gcc -O1 -c code.c

 #编译链接生成可执行文件：
 $>gcc -O1 -o prog code.o main.c

 #反汇编：
 $> objdump -d prog	
```

全局变量的地址确定是在 **链接阶段**

由于从16位的体系结构扩展到32位的，**Intel用“字”(word)来表示16位数据类型，称32位数为“双子”(double word),称64位为“四字”(quad word)** 。

一个IA32CPU有8个32位的寄存器，名字以“e%”开头，前6个(%eax,%ecx,%edx,%ebx,%esi,%edi)寄存器大多数情况下是通用没有限制的.最后2个（%ebp,%esp）保存着指向程序栈中重要位置的指针。

可以独立访问前四个寄存器的两个低位字节(%ah,%ch,%dh,%bh)，以兼容16位体系结构。

指令操作数有三种类型：**立即数，寄存器，存储器（主存）**

IA32限制，传送指令的两个操作数 **不能都指向存储器位置**,将一个值从一个存储器位置复制到另一个存储器位置需要两条指令——第一条将源值加载到寄存器，第二条将寄存器值写入目的位置。

MOVS：符号扩展，MOVZ，零扩展；将一个较小的源数据复制到一个较大的数据位置，符号扩展将用源值的 **最高为填充高位** ,而零扩展 **用零来填充高位**。


CPU的控制是通过采取条件码+跳转指令来进行的，CPU维护的一组单个位条件码(CF:无符号溢出 ; ZF:零; SF: 负数; OF: 有符号溢出），按照条件码的值，跳转到不同的指令位置。

CPU为了获取更好的性能，采取指令**流水线**。要使性能更好，必须使流水线上充满了指令。CPU采取 **预测技术** 来装载条件分支指令。如果预测错误，将需要重新装载指令，性能损耗大。**条件传送指令** 的方式可以避免这种情况，它会先计算每个分支的指令，然后按照条件码的值，复制到目的寄存器。

条件传送指令不只是总是有更好的性能，当分支指令需要大量的计算时，得不偿失。

switch语句使用称为 **“跳转表”**的一个数组，来记录分支代码段的位置。它的访问时间复杂度是O(1),即与表项个数无关。

过程调用采取“栈”来传递过程单数，存储返回位置信息，保存寄存器用于以后恢复，同时，在过程调用进入时，为过程分配的局部变量分配空间也在该栈上进行，并在退出红藕释放这些空间。

寄存器使用惯例：%eax,%edx,%ecx划分位调用者保存寄存器;%ebx,%esi,%edi划分位被被调用者保存寄存器。






















