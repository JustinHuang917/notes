《信息的表示与处理》
============

----------

**浮点数**溢出会产生特殊的值正无穷大。但一组正数的乘积总是正的，由于表示的精度有限，浮点运算是**不可结合的**。
eg：3.14+（1e20-1e20）=3.14; (3.14+1e20)-1e20=0.0

整数运算是精确的，而浮点数是近似的。

----------

**C语言版本演变：** K＆R第一版 (Bell Lab)——> ANSI C(美国国家标准) ——> ISO C90 (C89) ——> ISO C99  (gcc -std=c99 proc.c)

----------

**虚拟存储器：**将计算机的存储器视为一个非常大的数组，存储器的每个字节由一个数字来表示，称为地址。虚拟n存储器可以包括RAM，磁盘，特殊硬件等的虚拟访问。

----------

**十六进制的转换运算:**

对于x=2^n, x的二进制表示为1后面跟n个0，如：8=2^3=00001000 ，十六进制的数字0代表4个二进制0 。

所以当n表示为i+4j时，其中0<=i<=3时，可以将x写成开通的十六进制数字为1（i=0），2（i=1），4（i=2），8（i=3），后面跟随j个十六进制的0.

如 x=2048=2^11,所以有n=11=3+4＊2.从而得到x=0x800

----------

**C中数据类型的字节数**
_______________________________________________________
C类型		|	32bit机器	|		64bit机器          
_______________________________________________________
													    	
char 		|		1		|			1
_______________________________________________________
short int	|		2		|			2
_______________________________________________________
int			|		4		|			4
_______________________________________________________
long int	|		4		|			8
_______________________________________________________
long long int |		8		|			8
_______________________________________________________
char *		 | 		4		|			8
_______________________________________________________
float		|		4		|			4
_______________________________________________________
double		|		8		|			8
________________________________________________________

----------

**寻址**
多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中**最小地址**

**little endian:** 最低有效数字在最前面的方式,大多数Intel兼容机都采取这种规则
**big endian:**	 最高有效数字在最前面的方式，大多数IBM和Sun MicroSystem采取这种规则

eg： 假设x为int，位于地址0x100，值为0x01234567，占四个字节

little endian： 0x100(01) 0x101(23) 0x102(45) 0x103(67)

big endian： 0x100(67) 0x101(45) 0x102(23) 0x103(01) 

----------

**布尔代数：**

异或：^,当p=0 且 q=1 或者 p=1 且q=0,p^q=1

----------

**移位运算：**

左移：x=01100011  x<<4=00110000

逻辑右移动：x=01100011 x>>4==00000110

算术右移: x=01100011 x>>4=11111001 (左端补k个最高有效位的值)

大多数编译器／机器组合都对有符号书进行算术右移

C语言中，加法（减法）优先级高于移位运算。即1<<2+3<<4 = 1<<(2+3)<<4 。


x<<k = z^k * x

x>>k = x / 2^k (无符号数使用逻辑右移，有符号数字使用数学右移)

----------

**整数表示**

有符号整数表示采用补码表示，即最高位为1时，表示值为负，最高为为0时，表示值为非负（包括0） 

补码的范围不固定:|TMin|=|TMax|+1 

补码能表示的正数比负数少一个，因为0是非负数。

最大的无符号数值刚好比补码的最大值大1，即UMax=2TMax+1 

C中的强制类型转换的结果是保持位值不变，只是改变了**解释**这些位的方式

```c
unsigned u=4294967295u ;/*UMax_32*/

int tu= (int)u ;

tu == -1 ;

```

C中的比较
运算，当一个运算数是无符号时，另一个运算数会被隐式转换为无符号，如-1<0u, 即转换为4294967295U<0U，结果是false

----------


**浮点数表示**

二进制小数：101.11_2= 1*2^2 + 0*2^1 + 1*2^0 + 1*2^-1 + 1*2^-2=4+0+1+1/2+1/4=5 + 3/4

二进制小数点向左移动一位相当于将该数乘以2，如：1011.1=8+0+2+1+1/2=11+1/2 

浮点数只能近似表示实数，采用**舍入**的方式来求近似值，舍入有四种情况：**向偶数舍入，向零舍入，向下舍入，向上舍入**



《程序的机器级表示》
============

基本编译命令：
``` sh
 #生成汇编代码:"-S"表示生成汇编代码，"-O1"表示做level 1的优化
 $>gcc -O1 -S code.c

 #生成Intel格式的汇编代码：
 $>gcc -O1 -S -masm=intel code.c 

 #编译并汇编代码：
 $>gcc -O1 -c code.c

 #编译链接生成可执行文件：
 $>gcc -O1 -o prog code.o main.c

 #反汇编：
 $> objdump -d prog	
```

全局变量的地址确定是在 **链接阶段**

由于从16位的体系结构扩展到32位的，**Intel用“字”(word)来表示16位数据类型，称32位数为“双子”(double word),称64位为“四字”(quad word)** 。

一个IA32CPU有8个32位的寄存器，名字以“e%”开头，前6个(%eax,%ecx,%edx,%ebx,%esi,%edi)寄存器大多数情况下是通用没有限制的.最后2个（%ebp,%esp）保存着指向程序栈中重要位置的指针。

可以独立访问前四个寄存器的两个低位字节(%ah,%ch,%dh,%bh)，以兼容16位体系结构。

指令操作数有三种类型：**立即数，寄存器，存储器（主存）**

IA32限制，传送指令的两个操作数 **不能都指向存储器位置**,将一个值从一个存储器位置复制到另一个存储器位置需要两条指令——第一条将源值加载到寄存器，第二条将寄存器值写入目的位置。

MOVS：符号扩展，MOVZ，零扩展；将一个较小的源数据复制到一个较大的数据位置，符号扩展将用源值的 **最高为填充高位** ,而零扩展 **用零来填充高位**。


CPU的控制是通过采取条件码+跳转指令来进行的，CPU维护的一组单个位条件码(CF:无符号溢出 ; ZF:零; SF: 负数; OF: 有符号溢出），按照条件码的值，跳转到不同的指令位置。

CPU为了获取更好的性能，采取指令**流水线**。要使性能更好，必须使流水线上充满了指令。CPU采取 **预测技术** 来装载条件分支指令。如果预测错误，将需要重新装载指令，性能损耗大。**条件传送指令** 的方式可以避免这种情况，它会先计算每个分支的指令，然后按照条件码的值，复制到目的寄存器。

条件传送指令不只是总是有更好的性能，当分支指令需要大量的计算时，得不偿失。

switch语句使用称为 **“跳转表”**的一个数组，来记录分支代码段的位置。它的访问时间复杂度是O(1),即与表项个数无关。

过程调用采取“栈”来传递过程单数，存储返回位置信息，保存寄存器用于以后恢复，同时，在过程调用进入时，为过程分配的局部变量分配空间也在该栈上进行，并在退出红藕释放这些空间。

寄存器使用惯例：%eax,%edx,%ecx划分位调用者保存寄存器;%ebx,%esi,%edi划分位被被调用者保存寄存器。

**数据对齐** ：当结构的数据元素的长度都是2的幂时，一种有效的对齐策略是 **按照大小的降序排列结构的元素**

**函数指针**: 函数指针的值是该函数机器代码表示的第一条指令的指针
``` c
 int fun(int x,int *p)
 {
 }
 
 (int)(*fp)(int,int *);
 fp=fun;
 int y=1;
 int result=fp(3,&y); 
```



《优化程序性能》
================

性能优化：

* 高级优化：适当的算法和数据结构

* 基本编码原则：
 
	> 减少循环条件中的过程调用

	> 减少循环体内的过程调用

	> 减少对存储器的引用，使用临时变量保存中间结果，只有在最后的值计算出来时，才将结果存回到数组或全局变量种

* 低级优化:

	> 展开循环，降低开销
   
    > 通过使用例如多个累积变量和重新结合的技术，找到方法提高指令级并行

    > 用功能风格重写条件操作，使得编译采用条件传送指令


C性能剖析：
```sh
    
    #使用参数“-pg”编译
	$> gcc	-O1 -pg prog.c -o p

    #执行程序后，将生成gmon.out文件
    $> ./p

    #用GPROF来分析gmon.out中的数据
    $> gprof prog

```

**Amdal定律**:当我们加快系统一个部分的速度时，对系统整体性能的影响依赖于这个部分有多重要和速度提高了多少

公式：1/(（1-α）+α/k)

其中：α：被加快部分原来占用系统性能的比例（如：60%），k：被加快部分提升的倍数(如：3倍) 。得：1/((1-0.6)+0.6/3)=1/0.4+0.2=1.67



《存储器层次结构》
================

**各存储器的访问周期**

 * 寄存器：零个周期内
 
 * 高速缓存：1-30个周期

 * 主存：50-200个周期

 * 磁盘：几千万个周期

**RAM:** 随机访问存储器

 * **SRAM:** 静态随机访问存储器,将每个位存储在一个*双稳态*的存储器单元，由于双稳，只要有电，就能永远保持它的值，即使有干扰（如电子噪音）。

 * **DRAM：** 动态随机访问存储器，将每个位存储在对一个电容的充电，容易被干扰，需要周期性的刷新来保持值。

 * **对比**：SRAM稳定不需要刷新，存储比DRAM快，但SRAM单元比DRAM单元使用更多晶体管，因而密度低，贵，功耗大。SRAM应用于高速缓存存储器，DRAM应用于主存。


**磁盘：**
 
 **磁道：** 盘片表面上的一组同心圆。
 
 **记录密度：** 位/英寸，磁道一英寸的段中可以放入的位数
 
 **磁道密度：** 道/英寸，从盘片中心出发的半径上一寸的段内可以有的磁道数

 **面密度：** 记录密度×磁道密度

 **扇区：** 每个磁道被划分为一组扇区，每个扇区含有相等数量的数据位（通常位512bit）

 **磁盘容量**=每扇区字节数 × 每磁道平均扇区数 × 每表面磁道数 × 盘片表面数 × 每个磁盘盘片数

对于SRAM/DRAM：K=2^10,M=2^20,G=2^30,T=2^40

对于磁盘（或网络I/O）：K=10^3,M=10^6,G=10^9,T=10^12

磁盘访问时间=寻到时间 + 旋转时间 + 传送时间


**磁盘访问过程：**
 
 * CPU通过命令，逻辑块号和目的存储器地址写到与磁盘相关联的存储器映射地址，发起一个磁盘读。

 * 磁盘控制器读扇区，并执行到主存的DMA传送

 * 当DMA传送完毕，磁盘控制器用**中断(命令字，逻辑块号，主存地址)**的方式通知CPU 

 * 磁盘控制器收到CPU的读命令后，由磁盘控制器完成将内容读到主存的过程，并通知CPU，而**不需要CPU的干涉**



**局部性：**

局部性好的例子

``` c 
int sumarrayrows(int a[m][n])
｛
	int i,j,sum=0;
	for(i=0;i<M;i++){
		for(j=0;j<N;j++){
			sum+=a[i][j];
		}
	}
	return sum;
｝
```
空间局部性差的例子：
``` c
int sumarrayrows(int a[m][n])
｛
	int i,j,sum=0;
	for(j=0;j<M;i++){
		for(i=0;i<N;j++){
			sum+=a[i][j];
		}
	}
	return sum;
｝
```


《异常控制流》
==========

**异常**
<table>
<tr><th>类别	</th><th>原因</th><th>异步/同步</th><th>返回行为</th><th>常见</th></tr>

<tr><td>中断</td><td>来自I/O设备的原因</td><td>异步</td><td>总是返回到下一指令</td><td>I/O处理</td><td></tr

<tr><td>陷阱</td><td>有意的异常</td><td>同步</td><td>总是返回到下一指令</td><td>syscall</td></tr>

<tr><td>故障</td><td>潜在可恢复的错误</td><td>同步</td><td>可能回到下一指令</td><td>缺页异常</td></tr>

<tr><td>终止</td><td>不可恢复的错误</td><td>同步</td><td>不会返回</td><td>硬件错误/除法错误</tr></tr>

</table>

**异常于系统调用**

IA32系统定义了256种异常，0-31位Intel定义，32-255对应操作系统的中断和陷阱，每个异常都有对应一个异常号。syscall可传入一个异常号，来完成系统调用，寄存器%eax包含系统调用号，寄存器%ebx，%ecx，%edx，%esi，%edi和%edp包含最多六个参数，多余参数的话需要采用间接地址传递。

**并发与并行**

一个逻辑流的执行在时间上与另一个流重叠，称为**并发流**。并发于处理器核数或计算机数无关，并行是并发流的一个真子集,如果两个流并发地运行在不同的处理器核或计算机上，则称为**并行流**。

**fork子进程**

 * 新fork出的子进程与父进程几乎相同（虚拟地址的copy,包括文本，数据和bss段，堆以及用户栈，文件描述符也相同），唯一不同的是PID

 * fork函数是**一次调用，两次返回**,一次在调用进程（父进程）种，一次在新创建的子进程中，**父进程中fork返回子进程的pid，在子进程种返回0** 。
``` c
int main()
{
  pid_t pid;
  int x=1;
  
  pid=fork();
  //子进程中的执行
  if(pid==0){
     printf("child: x=%d\n",x++);//x在子进程中与父进程中是独立的地址空间。
  }
 //父进程中执行
 printf("parent: x=%d\n",--x);
 exit(0);
}
//输出：
//parent: x=0;
//child:  x=2;

```

《虚拟存储器》
=============

虚拟存储器采用分页机制来完成磁盘于主存交换的原因：提高命中率;抵销磁盘的随机访问开销;

**页表**用于保存虚拟也是否存放在DRAM中的某个地方，以及保存页对应的主存地址或者磁盘地址（未存放在DRAM时）。页表内容由OS来维护。当通过页表判断出一个页未被分配主存缓存时，触发一个缺页异常。

**内存访问过程**

（1）找到数据的指针。（指针可能存放在寄存器内，所以这一步就已经包括寄存器的全部工作了。

（2）将指针送往内存管理单元（MMU），由MMU将虚拟的内存地址翻译成实际的物理地址。

（3）将物理地址送往内存控制器（memory controller），由内存控制器找出该地址在哪一根内存插槽（bank）上。

（4）确定数据在哪一个内存块（chunk）上，从该块读取数据。

（5）数据先送回内存控制器，再送回CPU，然后开始使用。


