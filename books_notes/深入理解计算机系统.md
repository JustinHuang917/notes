《信息的表示与处理》
============

----------

**浮点数**溢出会产生特殊的值正无穷大。但一组正数的乘积总是正的，由于表示的精度有限，浮点运算是**不可结合的**。
eg：3.14+（1e20-1e20）=3.14; (3.14+1e20)-1e20=0.0

整数运算是精确的，而浮点数是近似的。

----------

**C语言版本演变：** K＆R第一版 (Bell Lab)——> ANSI C(美国国家标准) ——> ISO C90 (C89) ——> ISO C99  (gcc -std=c99 proc.c)
----------

**虚拟存储器：**将计算机的存储器视为一个非常大的数组，存储器的每个字节由一个数字来表示，称为地址。虚拟n存储器可以包括RAM，磁盘，特殊硬件等的虚拟访问。

----------

**十六进制的转换运算:**

对于x=2^n, x的二进制表示为1后面跟n个0，如：8=2^3=00001000 ，十六进制的数字0代表4个二进制0 。

所以当n表示为i+4j时，其中0<=i<=3时，可以将x写成开通的十六进制数字为1（i=0），2（i=1），4（i=2），8（i=3），后面跟随j个十六进制的0.

如 x=2048=2^11,所以有n=11=3+4＊2.从而得到x=0x800

----------

**C中数据类型的字节数**
_______________________________________________________
C类型		|	32bit机器	|		64bit机器          
_______________________________________________________
													    	
char 		|		1		|			1
_______________________________________________________
short int	|		2		|			2
_______________________________________________________
int			|		4		|			4
_______________________________________________________
long int	|		4		|			8
_______________________________________________________
long long int |		8		|			8
_______________________________________________________
char *		 | 		4		|			8
_______________________________________________________
float		|		4		|			4
_______________________________________________________
double		|		8		|			8
________________________________________________________

----------

**寻址**
多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中**最小地址**

**little endian:** 最低有效数字在最前面的方式,大多数Intel兼容机都采取这种规则
**big endian:**	 最高有效数字在最前面的方式，大多数IBM和Sun MicroSystem采取这种规则

eg： 假设x为int，位于地址0x100，值为0x01234567，占四个字节

little endian： 0x100(01) 0x101(23) 0x102(45) 0x103(67)

big endian： 0x100(67) 0x101(45) 0x102(23) 0x103(01) 

----------

**布尔代数：**

异或：^,当p=0 且 q=1 或者 p=1 且q=0,p^q=1

----------

**移位运算：**

左移：x=01100011  x<<4=00110000

逻辑右移动：x=01100011 x>>4==00000110

算术右移: x=01100011 x>>4=11111001 (左端补k个最高有效位的值)

大多数编译器／机器组合都对有符号书进行算术右移

C语言中，加法（减法）优先级高于移位运算。即1<<2+3<<4 = 1<<(2+3)<<4 。


x<<k = z^k * x

x>>k = x / 2^k (无符号数使用逻辑右移，有符号数字使用数学右移)

----------

**整数表示**

有符号整数表示采用补码表示，即最高位为1时，表示值为负，最高为为0时，表示值为非负（包括0） 

补码的范围不固定:|TMin|=|TMax|+1 

补码能表示的正数比负数少一个，因为0是非负数。

最大的无符号数值刚好比补码的最大值大1，即UMax=2TMax+1 

C中的强制类型转换的结果是保持位值不变，只是改变了**解释**这些位的方式

```c
unsigned u=4294967295u ;/*UMax_32*/

int tu= (int)u ;

tu == -1 ;

```

C中的比较
运算，当一个运算数是无符号时，另一个运算数会被隐式转换为无符号，如-1<0u, 即转换为4294967295U<0U，结果是false

----------


**浮点数表示**

二进制小数：101.11_2= 1*2^2 + 0*2^1 + 1*2^0 + 1*2^-1 + 1*2^-2=4+0+1+1/2+1/4=5 + 3/4

二进制小数点向左移动一位相当于将该数乘以2，如：1011.1=8+0+2+1+1/2=11+1/2 

浮点数只能近似表示实数，采用**舍入**的方式来求近似值，舍入有四种情况：**向偶数舍入，向零舍入，向下舍入，向上舍入**



《程序的机器级表示》
============



